package com.test.datastructure.hash;

public class Note {
    /**
     * 什么是哈希表
     *  int[26] freq 就是一个哈希表
     *  每一个字符都和一个索引相对应，index = ch - 'a'
     *  这个相对应的逻辑就是 哈希函数
     *
     *  很难保证每一个键通过哈希函数的转换对应不同的索引
     *  因此需要解决哈希冲突
     *
     *  哈希函数的设计，转成整型处理不是唯一的方法，遵循原则：
     *  1. 一致性：如果 a == b，则 hash(a) == hash(b)
     *  2. 高效性：计算高效简便
     *  3. 均匀性：哈希值均匀分布
     *
     * 解决哈希冲突的方式
     *  1. 在一个固定大小的数组中，如果某个索引上有多个元素，那么这多个元素以链表的形式存放
     *     就可以解决哈希冲突，即 链地址法
     *  2. 不一定是一个链表，也可以是一个比如treeMap
     *     在Java8之前，每一个位置对应一个链表
     *     从Java8开始，当哈希冲突达到一定程度，每一个位置从链表转成红黑树
     *
     * 时间复杂度分析：
     *  总共有M个地址，放入哈希表的元素为N
     *  1. 如果每个地址是链表：    O(N/M)       最坏情况 O(N)
     *  2. 如果每个地址是平衡树：  O(log(N/M))  最坏情况 O(log(N))
     *
     * 使用固定大小的数组是不合理的，需要扩容，即哈希表的动态空间处理
     *  1. 平均每个地址承载的元素多过一定程度，即扩容，N / M >= upperTol
     *  2. 平均每个地址承载的元素少过一定程度，即缩容，N / M < lowerTol
     *
     * 最终哈希表的时间复杂度为O(1)级别的，但是牺牲了 顺序性
     */
}
