package com.test.datastructure.tree;

/**
 * 笔记
 */
public class Note {
    /**
     * 二叉树：
     *
     *  class Node{
     *      E e;
     *      Node left;
     *      Node right;
     *  }
     *
     *
     * 二叉树特点：
     *  1.有 唯一 根节点
     *  2.每个节点最多有 两个 子节点
     *  3.每个节点最多有 一个 父节点
     *  4.没有 子节点 的节点叫 叶子节点
     *
     *
     * 二分搜索树特点：(Binary Search Tree)
     *  1.也是二叉树
     *  2.存储的元素必须有可比较性
     *  3.每个节点的值大于其 左子树 任意节点的值
     *              小于其 右子树 任意节点的值
     *    这种情况下的二分搜索树 不存在 重复 元素
     *  4.每个节点的值大于等于其 左子树 任意节点的值
     *          或者 小于等于其 右子树 任意节点的值
     *    这种情况下的二分搜索树 存在 重复 元素
     *
     *
     * 对于遍历操作，两棵子树都要顾及
     *
     * 二分搜索树的 前序遍历
     *  先访问父节点，再访问父节点的 左右两个 子节点
     *  对 父节点 的访问放在最前面
     *
     * 二分搜索树的 中序遍历
     *  先访问 左子节点，再访问 父节点，再访问 右子节点
     *  对 父节点 的访问放在中间
     *  中序遍历特点：遍历的顺序是 从小到大
     *
     * 二分搜索树的 后序遍历
     *  先访问 左子节点，再访问 右子节点，再访问 父节点
     *
     * 二分搜索树的 前序遍历 非递归实现
     *  需要借助 栈 来实现
     *
     * 二分搜索树的 层序遍历
     *  二分搜索树的 前序 中序 后序 遍历都是 深度优先遍历
     *                     而 层序遍历 是 广度优先遍历
     *  需要借助 队列 来实现，不能通过 递归 来实现
     *
     *
     * 二分搜索树 删除节点
     *
     *  删除最小节点
     *
     *  删除最大节点
     *
     *  删除某个节点
     *            只有左子树
     *            只有右子树
     *            左右子树都有：用 右边最小节点 替代被删除的节点
     *                   或者 用 左边最大节点 替代被删除的节点
     *
     */
}
