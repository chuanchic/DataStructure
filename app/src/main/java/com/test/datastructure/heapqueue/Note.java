package com.test.datastructure.heapqueue;

public class Note {

    /**
     * 优先队列
     *
     *  普通队列： 先进先出
     *  优先队列： 出队顺序和进队顺序无关，和优先级有关
     *
     *  普通线性结构 实现 优先队列： 入队 O(1)     出队O(n)
     *  顺序线性结构 实现 优先队列： 入队 O(n)     出队O(1)
     *          堆 实现 优先队列： 入队 O(logn)  出队O(logn)
     *
     *
     * 二叉堆(Binary Heap)特性：
     *
     * 1.是一棵完全二叉树，不一定是满二叉树，当节点不满的情况下，优先放在左边
     *   即把元素 顺序 排列成树的形状，一层一层的 从左向右放
     *
     * 2.父节点 大于等于 子节点，这种特性下的堆也叫 最大堆
     *   相应的也能定义出 最小堆
     *
     *
     * 用数组实现 二叉堆：
     *
     *  对于给定的节点索引 i：
     *
     *  parent (i) = i / 2
     *
     *  left child (i) = 2 * i
     *
     *  right child (i) = 2 * i + 1
     *
     *  或者
     *
     *  parent (i) = (i - 1) / 2
     *
     *  left child (i) = 2 * i + 1
     *
     *  right child (i) = 2 * i + 2
     *
     *  添加操作，在数组最后位置添加元素，然后做 上浮 sift up
     *
     *  删除 最大值 操作，删除数组第一个元素，把最后一个元素拿到第一个位置，然后做 下浮 sift down
     *
     *  时间复杂度分析：
     *  add() 和 extractMax() 都是 O(logn) 级别的，是一个完全二叉树，不会存在最差情况 O(n)
     *
     *  replace 操作：
     *   方式一：可以先 extractMax 然后在 add，这样需要两次 O(logn)
     *   方式二：可以将堆顶元素替换成新的元素，然后在 siftDown，这样就一次 O(logn)
     *
     *  heapify 操作：
     *          就是将一个数组 转成 二叉堆，将所有的非叶子节点 下沉 siftDown 就行了
     *          需要找到最后一个非叶子节点，也就是数组最后一个元素的父节点
     *          然后从最后一个非叶子节点开始向前遍历，进行 siftDown 操作
     *          这样操作的时间复杂度是 O(logn)，而创建一个空堆然后依次添加元素则是 O(n)
     *
     *
     * 基于 MaxHeap 实现的优先队列
     *
     *
     *
     */
}
